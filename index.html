<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>TypeScript Deep Dive</title>

		<meta name="description" content="Typescript Education">
		<meta name="author" content="Basarat Ali Syed">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/source/skybold.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">


            <section class="git" data-state="git">
					<h1>TypeScript</h1>
                    <h2>Deep Dive</h2>                    
					<p>Specification * Recommendations * Patterns</p>
					<br/>
					<p>
						<small>Created by <a href="http://basarat.com">BAS (Basarat Ali Syed)</a> / <a href="http://twitter.com/basarat">@basarat</a></small>
					</p>
				</section>

				<section>
					<h2>What does typescript provide?</h2>
                    <ul>
                        <li>Strong Typing</li>
                        <li>Better Syntax</li>
                    </ul>
					<aside class="notes">
                        The two things typescript provides
					</aside>
				</section>


				<!-- Example of nested vertical slides -->
				<section>
                    <section>
					    <markdown>
Strong Typing
---

- Interfaces
- Inline typing (type declarations)
- Ambients
 - Variable
 - Functions
 - Classes
 - Modules

	
					    </markdown>
                    </section>
				</section>
				
				<section>
					<section><h1>Interfaces</h1> What do you want from me?</section>	
					
					<section>
						<h2>Interfaces</h2>
						<codeseg>
interface fooInterface{
    // constructor
    new (fooParam1:number,fooParam2?):number;

    // call signature callable without new
    (fooParam1:any):string;

    // indexable
    [index:string]:number;
}
                        </codeseg>
					</section>
                    <section>
						<h2>Interfaces</h2>
						<codeseg>
interface fooInterface{
    // functions with overloads
    fooFunc1(fooParam1:bool):any;
    fooFunc2(...fooParam1:number[]):any;
    fooFunc3:(fooParam1:bool)=>any;

    // variables
    fooVar1:number;
    fooVar2?:Array;

    // array
    fooArr1:{
        [index:string]:number;
    };
    fooArr2:number[];
}
                            </codeseg>
					</section>
				</section>
				
				<section>
					<section>
						<h1>Declaration</h1>What is that?
					</section>
					<section> 
						<h2>Type Annotation</h2>
						<codeseg>
var x:number;
var y:string;
var z:number[];
var foo:{a:any;b:()=>any;} // powerful inline declaration
						<codeseg>						
					</section>
					
					<section>
						<h2>inline declarations</h2>
						Offer the complete Interface syntax but inline. Syntax:
						<codeseg>
var __varname__: { 
	__membername__ : __membertype__ ;
	__membername__ : __membertype__ ;
	// Repeat
}
						</codeseg>
						e.g:
						<codeseg>
var x:{ 
	() : Function; 
	[foo:string]: number;
	new() : string;
}
						</codeseg>
					</section>		
					
					<section>
						<h2>Function signature</h2>
						<codeseg>
// interface / inline interface implementation
interface fooInterface{	
	simpleSyntax():void;
	lambdaSyntax:()=>void;
}

var fooInline:{	
	simpleSyntax():void;
	lambdaSyntax:()=>void;
}
						</codeseg>
						Lambda signature is required for function signatures in vars / parameter type declarations. 
					</section>		
					<section>
						<h2>Function signature for callables</h2>
						A bit inconsistent.
						<codeseg>

// Simple function, When declaring a var or function arguments
var x1 : (s: string)=>string; 
// When saying something is callable
var x2 : { (s: string): string; }
interface x3{
	(s:string):string;
}

// Errors:
var y1 : (s: string):string;
var y2: { (s: string)=> string; }
interface y3{
	(s:string)=>string;
}
					</codeseg>
					</section>
					<section> 
						<h2>Type Inference</h2>							
						<codeseg>
var x = 123;
var y; 
y = 123;

x = "asdf"; 
y = "asdf"; 

var z={foo:123}
						</codeseg>
						What type is y?
						Does the compiler give an error in this code segment?
					</section> 
					
					<section>
						<h2>any</h2>							
						<codeseg>
var x:any;
var y:number = x;
x = y;	
						</codeseg>
						Can be assigned to anything. Can be assigned anything. 						
					</section>			
					
					<section>
						<h2>null, undefined</h2>							
						Typescript: For compiler (not runtime) both are type any. 						
						<codeseg>
var x = null;
var y = undefined;		
						</codeseg>
						Javascript: null is an object instance to mean nothing. undefined is a type as well as a value for something not initialized. 
						<codeseg>
var TestVar;
alert(TestVar); //shows undefined
alert(typeof TestVar); //shows undefined

var TestVar = null;
alert(TestVar); //shows null
alert(typeof TestVar); //shows object
						</codeseg>						
					</section>			
						
					<section>
						<h2>Which string is that?</h2>
						<codeseg>
var obj:String = "123";
var primitive:string = "123";

obj=primitive; // exactly what the first line is doing
primitive=obj; // Error  
						</codeseg>
						Recommendation: Just use string.
					</section>
				</section>
					
				<section>			
				
					<section><h1>Ambients</h1>I thought I saw a pussy cat</section>
					<section>
						<h2>Ambients</h2>
<markdown>The magical keyword is ***declare***.

Generate no code whatsoever so obviously

- no variable initializer
- no function bodies / no default parameters</markdown>
					</section>
                    <section>
                        <h2>Ambients</h2>
                        <codeseg>
declare var angular;
declare function foo(takes:string):number;
declare class Fancy{
    notMuch:string;
}
					</codeseg>
                    </section>

				</section>

                <section>
                    <section>
                    <h2>Better Syntax</h2>
<markdown>- Function signatures
 - Optional parameters
 - Rest parameters
 - Default parameters
 - Arrow Functions
- Classes
 - super
 - public / private
- Modules
 - Internal
 - AMD / CommonJS</markdown>
                    </section>
                </section>

				<section>
					<section>
						<h1>Functions</h1>
						are actually functions
					</section>					
					<section>
						<h2> Optional </h2> 
						??????
						<codeseg> 
function foo(req:string,optional?:number){}
						</codeseg>
					</section>
					<section>
						<h2>Default</h2> 
						<p>Effectively optional. Can even do expressions</p>
						<codeseg> 
function foo( req:string, def:number=3, optional=req+def ) { } 
						</codeseg>
						Generates: 
						<codeseg>
function foo(req, def, optional) {
    if (typeof def === "undefined") { def = 3; }
    if (typeof optional === "undefined") { optional = req + def; }
}				
						</codeseg>
					</section>
					<section>
						<h2>Rest</h2>
						<markdown>
params denoted by ... 
 
- explicitly type declared 
- have to be last
						</markdown>
						<codeseg>
function foo(req:string,...blabla:any[]){}
						</codeseg> 
						becomes
						<codeseg>
function foo(req) {
    var blabla = [];
    for (var _i = 0; _i < (arguments.length - 1); _i++) {
        blabla[_i] = arguments[_i + 1];
    }
}
						</codeseg>
					</section> 
					<section>
						<h2>Function overloading</h2>
						<codeseg>
interface IFoo{
    test(x:string);
    test(x:number);
}
						</codeseg>
					</section>
					<section>
						<h2>Function overloading</h2>
						The actual function should be able to accept any of the overload members.
						<codeseg>
class Foo implements IFoo {
    test(x: string);
    test(x: number);
    test(x: any) {
        if (typeof x === "string") {
            //string code
        } else {
            //number code
        }
    }
}
						</codeseg>
						The overloads go through the same code generation restrictions e.g you cannot define default values etc.
					</section>
					<section>
						<h2>Function overloading</h2>
						How to handle variable parameters
						<codeseg>
function f():number; // Error 
function f(x:any):any{
}

function g():number; // Okay 
function g(x?:any):any{
}

						</codeseg>
						Don't need to be in a class. 						
						
					</section>
					
					<section>
						<h2>Function Instances</h2>
						<codeseg>
// global or module 
function simpleSyntax():void{}
var lambdaSyntax1=():void=>{}

// class , basically remove function or var
class fooClass{
	simpleSyntax():void{}
	lambdaSyntax=():void=>{}	
}

// object literal 
var fooObject={
	simpleSytax: function():void{},
	lambdaSyntax: ():void=>{}	
}
// Reminder the lambda based signature was a bit different: 
// lambdaSyntax:()=>void;
						</codeseg> 
					</section>		
					
				</section>
				<section>
					<section>
						<h1>Class</h1>
						Now called class 
					</section>
					<section>
						<h2>Basic</h2>						
						<codeseg>
class Foo{
	public member:number;
	
	static stat:number = 123;
	
	constructor(){this.member = 123;}
	
	func(){
		this.member = 256;
	}
}
						</codeseg>
						Note: to access members you ALWAYS have to use this
					</section>
					<section>
						<h2>Basic</h2>
						<codeseg>
var Foo = (function () {
    function Foo() {
        this.member = 123;
    }
    Foo.stat = 123;
    Foo.prototype.func = function () {
        this.member = 256;
    };
    return Foo;
})();

						</codeseg>	
					</section>
					<section>
						<h2>Basic</h2>
						<codeseg>
class Foo{
	
	constructor(public member){this.member = 123;}
	
	func(){
		this.member = 256;
	}
}
						</codeseg>
					</section>
					<section>
						<h2>Cool: Member not generated</h2>
						<codeseg>
class Foo{
	public member:number;
}						
						</codeseg>						
						becomes: 
						<codeseg>
var Foo = (function () {
    function Foo() { }
    return Foo;
})();
						</codeseg>						
					</section>					
					
					<section>
						<h2>Interface implementation</h2>
						Primarily for the person implementing the class. The class can be used in place of the interface even if it doesn't explictly implement that interface. 
						<codeseg>
interface iFoo{
	x:number;
}
class Foo1 implements iFoo{
	x:number;
}
class Foo2{
	x:number;
}

var la:iFoo;
la = new Foo1();
la = new Foo2(); 
						</codeseg> 
					</section>		

					<section>
                        <h2>Syntax Limitations</h2>
                        <p>
                            Not everthing that can be declared in an interface can be implemented by a Typescript class e.g. Indexible, call signatures
                        </p>
						<codeseg>
interface WidgetMap {
    [name: string]: Widget;
}

var map: WidgetMap = {};
map['gear'] = new GearWidget();
var w = map['gear']; // w is inferred to type Widget
						</codeseg>
                    </section>
					
					<section>
						<h2>Optional members?</h2>						
						<codeseg>
interface foo{
	x?:number;
}

class boo1 implements foo{		
}

class boo2 implements foo{
	x:number;	
}
						</codeseg>
					</section>
					
				</section>
				
				<section>
					<section>
						<h1>Class Inheritance</h1>
						<strong>super</strong> : Not the Australian kind. 
					</section>			
					
					<section>
						<h2>Basic</h2>
						<codeseg>
class FooBase{	 
}

class FooChild extends FooBase{	
}						
						</codeseg> 
					</section>
					
					<section>
						<h2>Basic</h2>
						<codeseg>
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var FooBase = (function () {
    function FooBase() { }
    return FooBase;
})();
var FooChild = (function (_super) {
    __extends(FooChild, _super);
    function FooChild() {
        _super.apply(this, arguments);

    }
    return FooChild;
})(FooBase);
						</codeseg> 
					</section>
					<section>
						<h2>Static is Broken</h2>
<codeseg>
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
</codeseg>
vs.
<codeseg>
var __extends = this.__extends || function(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function f() { this.constructor = d; }
    f.prototype = b.prototype;
    d.prototype = new f();
}
</codeseg> 
<a href="http://typescript.codeplex.com/workitem/825">work item</a>
					</section>
					
					
					<section>
						<h2>super</h2>						
						<codeseg>
class base {
	test(foo:number){
		console.log(foo);
	}
}
class child extends base{
	constructor(public x:number){
		super();				 	
		super.test(x); // 15
		this.test(x); // 25 		
	}
	test(foo:number){
		console.log(foo+10);
		
	}
}
var test=new child(15);
						</codeseg>
					</section>
					
					<section>
					<h2>super</h2>
					super called via call<br/>super (dot) goes directly to prototype
					<codeseg>
function child(x) {
	_super.call(this);
	this.x = x;
	_super.prototype.test.call(this, x);
	this.test(x);
}					
					</codeseg>
					</section>
					<section>
						<h2>Super Cautious</h2>
						<codeseg>
class A{
	fooMem=10;	
}
class B extends A{
	constructor(){
		console.log(this.fooMem); // undefined 
		super();		
		console.log(this.fooMem);
		console.log(super.fooMem); // undefined 		
	}
};
var test = new B();						
						</codeseg>						
						Make super first call and only use for function access afterwords. 
					</section>
				</section> 
				
				<section>
					<section><h1>this</h1> which one? </section>					
					<section>						
						<h2>Save me</h2>
						<markdown>
						Typescript knows. But doesn't mean it will save you.  
						
- Constructor / member functions
 - *this* a type of containing class 
- Static functions
 - *this* is of type constructor function
- All other places its any
						</markdown>
					</section>
					<section>
						<h2>Err</h2>
						Typescript will complain if you miss this. It will say member not defined. So novice way is to put in this. 
						<codeseg>
class Example{
	member = 10; 
	constructor(){		
		// Could have been an jquery call
		// you were porting from js
		setTimeout(function() {
			alert(this.member);
		},100);
	}	
}
var ex = new Example();
						</codeseg>
					</section>
					<section>
						<h2>Arrow Functions</h2>
						<codeseg>
// all of these are the same
var test1=(x:number)=>{return x*10};
var test2=(x:number)=>(x*10);
var test3=(x:number)=>x*10;
var test4=(x)=>x*10;
var test5=x=>x*10;

// {} require a return statement
// This is actually returning undefined
// which is a valid number and fails silently 
var test6=(x:number)=>{x*10};						
						</codeseg>						
					</section>						
						<section>
						<h2>Arrow Functions</h2>
							For lexical scoping.
						<codeseg>
var foo = () => {return this;}					
						</codeseg>
					generates:
						<codeseg>
var _this = this;
var foo = function () {
    return _this;
};					
						</codeseg>
					</section>
					<section>
						<h2>Err Fix</h2>						
						<codeseg>
				
class Example{
	member = 10; 
	constructor(){		
		// Could have been an jquery call
		// you were porting from js
		setTimeout(()=>{
			alert(this.member);
		},100);
	}	
}
var ex = new Example();
					</section>
					<section>
						<h2>So basically</h2>											
						Replace all functions in arguments with ()=> 
					</section>
					<section>
						<h2>Almost</h2>
						<markdown>
Keep functions for: 

- When you want this to be any. E.g. $.each. 
- When you need both. Then resort to the manual closure trick of  var self = this; 
						</markdown>
					</section>
					<section>
						<h2>Pattern</h2>
						When your class is just a collection of functions other people would call
						<codeseg>
class Example{
	func1:(number)=>void;
	func2:()=>number;
	
	member:number = 10;
	
	constructor(){
		this.func1=(x)=>{this.member=x};
		this.func2=()=>this.member;		
	}
}
						</codeseg>
						Useful for libs like knockout. 
					</section>
					
				</section> 		
				
				<section>
					<section><h1>Structural Typing</h1>Perhaps I can give you something else?</section>					
					
					<section>
						<h2>Class have their own brand</h2>
						<codeseg>
interface iFoo{
	x:number;
}
class Foo1 implements iFoo{
	x:number;
}
class Foo2{
	x:number;
}

var la:iFoo;
la = new Foo1();
la = new Foo2(); 

var fa:Foo1 = new Foo2(); //Error 
						</codeseg>
					</section>
					
					<section>					
					<h2>That brand is too mainstream</h2>
<b>Interfaces</b>, <b>inline</b> declarations and <b>inferred</b> structures are behaviour free. 
					<codeseg>
interface inter{
	foo:number;
}

var x:inter;

var y:{foo:number;}

var z={foo:123}

x=y=z;
z=y=x;
					</codeseg> 
					</section>
					
					<section>
						<h2>Its okay to have more</h2>
						<codeseg>
interface inter{
	foo:number;
}

var x:inter;

var y={
	foo:123,
	la:23
};

x = y;
y = x; //Error
					</codeseg>
					</section>
				</section> 			

				<section>
					<section><h1>Extending Built-ins</h1> You get it, I get it, But does the compiler get it?</section>					
					<section>
						<h2>Built-in Interfaces</h2>
						<markdown>
Present in lib.d.ts that ships with the typescript compiler. 						
						</markdown>
						<codeseg>
interface Array {
    toString(): string;
    toLocaleString(): string;
    concat(...items: _element[][]): _element[];
    concat(...items: _element[]): _element[];
    join(seperator?: string): string;
						</codeseg>
					</section>
					
					<section>
						<h2>Extend them</h2>
						Its just javascript
						<codeseg>
interface Array {
  shuffle: () => any; // <-- Whatever signature you want.
}

Array.prototype.shuffle = function () { ... };
						</codeseg>						
					</section>
					
				</section> 				

				<section>
					<section><h1>Type Assertion</h1>Cause I said so!</section>					
					<section>
						<h2>As simple as it gets</h2>
						<codeseg>
// error 
var x:HTMLCanvasElement	= document.getElementById("canvasId");
// valid 
var y:HTMLCanvasElement = &lt;HTMLCanvasElement&gt;document.getElementById("canvasId");
// type inferred 	  
var z = &lt;HTMLCanvasElement&gt;document.getElementById("canvasId");  
						</codeseg>
						Not type casting since you are only telling the compiler what to think, not actually changing what it is.
					</section>
				</section> 								
				
				<section>
					<section><h1>Template</h1></section>					
					<section>
						<h2>template</h2>
						<codeseg>
						</codeseg>
					</section>
				</section> 				

				<section>
				Also, 												
				exploit declration spaces for interface static members 
				declaration space and why you must import a module and not say var
				type assertion : i'm smarter than you. e.g. when getting a canvas 
				Pattern : static constructor 
				</section>
				
				<section>
					<h2>Tips</h2>
					<ul>
						<li>Think of your javascript as your call stack. Don't debug your Typescript.</li>						
						<li>Know your javascript. Don't use arguments as a variable name. Know what a prototype is.</li>						
						<li>Any valid javascript is valid typescript. Not unless you tell it</li>						
					</ul>
				</section>

				<section>
					<h2>Fantastic Ordered List</h2>
					<ol>
						<li>One is smaller than...</li>
						<li>Two is smaller than...</li>
						<li>Three!</li>
					</ol>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Markdown support

						For those of you who like that sort of thing. Instructions and a bit more info available [here](https://github.com/hakimel/reveal.js#markdown).

							<section data-markdown>
							  ## Markdown support

							  For those of you who like that sort of thing.
							  Instructions and a bit more info available [here](https://github.com/hakimel/reveal.js#markdown).
							</section>
					</script>
				</section>

				<section id="transitions">
					<h2>Transition Styles</h2>
					<p>
						You can select from different transitions, like: <br>
						<a href="?transition=cube#/transitions">Cube</a> -
						<a href="?transition=page#/transitions">Page</a> -
						<a href="?transition=concave#/transitions">Concave</a> -
						<a href="?transition=zoom#/transitions">Zoom</a> -
						<a href="?transition=linear#/transitions">Linear</a> -
						<a href="?transition=fade#/transitions">Fade</a> -
						<a href="?transition=none#/transitions">None</a> -
						<a href="?#/transitions">Default</a>
					</p>
				</section>

				<section id="themes">
					<h2>Themes</h2>
					<p>
						Reveal.js comes with a few themes built in: <br>
						<a href="?theme=sky#/themes">Sky</a> -
						<a href="?theme=beige#/themes">Beige</a> -
						<a href="?theme=simple#/themes">Simple</a> -
						<a href="?theme=serif#/themes">Serif</a> -
						<a href="?theme=night#/themes">Night</a> -
						<a href="?#/themes">Default</a>
					</p>
					<p>
						<small>
							* Theme demos are loaded after the presentation which leads to flicker. In production you should load your theme in the <code>&lt;head&gt;</code> using a <code>&lt;link&gt;</code>.
						</small>
					</p>
				</section>

				<section>
					<section data-state="alert">
						<h2>Global State</h2>
						<p>
							Set <code>data-state="something"</code> on a slide and <code>"something"</code>
							will be added as a class to the document element when the slide is open. This lets you
							apply broader style changes, like switching the background.
						</p>
						<a href="#" class="image navigate-down">
							<img width="178" height="238" src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
					</section>
					<section data-state="blackout">
						<h2>"blackout"</h2>
						<a href="#" class="image navigate-down">
							<img width="178" height="238" src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
					</section>
					<section data-state="soothe">
						<h2>"soothe"</h2>
						<a href="#" class="image navigate-next">
							<img width="178" height="238" src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Up arrow" style="-webkit-transform: rotate(-90deg);">
						</a>
					</section>
				</section>

				<section data-state="customevent">
					<h2>Custom Events</h2>
					<p>
						Additionally custom events can be triggered on a per slide basis by binding to the <code>data-state</code> name.
					</p>
					<pre><code contenteditable style="font-size: 18px; margin-top: 20px;">Reveal.addEventListener( 'customevent', function() {
	console.log( '"customevent" has fired' );
} );
					</code></pre>
				</section>

				<section>
					<h2>Clever Quotes</h2>
					<p>
						These guys come in two forms, inline: <q cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
						The nice thing about standards is that there are so many to choose from</q> and block:
					</p>
					<blockquote cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
						For years there has been a theory that millions of monkeys typing at random on millions of typewriters would
						reproduce the entire works of Shakespeare. The Internet has proven this theory to be untrue.
					</blockquote>
				</section>

				<section>
					<h2>Pretty Code</h2>
					<pre><code contenteditable>
function linkify( selector ) {
  if( supports3DTransforms ) {

    var nodes = document.querySelectorAll( selector );

    for( var i = 0, len = nodes.length; i &lt; len; i++ ) {
      var node = nodes[i];

      if( !node.className ) ) {
        node.className += ' roll';
      }
    };
  }
}
					</code></pre>
					<p>Courtesy of <a href="http://softwaremaniacs.org/soft/highlight/en/description/">highlight.js</a>.</p>
				</section>

				<section>
					<h2>Intergalactic Interconnections</h2>
					<p>
						You can link between slides internally,
						<a href="#/2/3">like this</a>.
					</p>
				</section>

				<section>
					<section>
						<h2>Fragmented Views</h2>
						<p>Hit the next arrow...</p>
						<p class="fragment">... to step through ...</p>
						<ol>
							<li class="fragment"><code>any type</code></li>
							<li class="fragment"><em>of view</em></li>
							<li class="fragment"><strong>fragments</strong></li>
						</ol>

						<aside class="notes">
							This slide has fragments which are also stepped through in the notes window.
						</aside>
					</section>
					<section>
						<h2>Fragment Styles</h2>
						<p>There's a few styles of fragments, like:</p>
						<p class="fragment grow">grow</p>
						<p class="fragment shrink">shrink</p>
						<p class="fragment roll-in">roll-in</p>
						<p class="fragment fade-out">fade-out</p>
						<p class="fragment highlight-red">highlight-red</p>
						<p class="fragment highlight-green">highlight-green</p>
						<p class="fragment highlight-blue">highlight-blue</p>
					</section>
				</section>

				<section>
					<h2>Spectacular image!</h2>
					<a class="image" href="http://lab.hakim.se/meny/" target="_blank">
						<img width="320" height="299" src="http://s3.amazonaws.com/hakim-static/portfolio/images/meny.png" alt="Meny">
					</a>
				</section>

				<section>
					<h2>Export to PDF</h2>
					<p>Presentations can be <a href="https://github.com/hakimel/reveal.js#pdf-export">exported to PDF</a>, below is an example that's been uploaded to SlideShare.</p>
					<iframe id="slideshare" src="http://www.slideshare.net/slideshow/embed_code/13872948" width="455" height="356" style="margin:0;overflow:hidden;border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe>
					<script>
						document.getElementById('slideshare').attributeName = 'allowfullscreen';
					</script>
				</section>

				<section>
					<h2>Take a Moment</h2>
					<p>
						Press b or period on your keyboard to enter the 'paused' mode. This mode is helpful when you want to take distracting slides off the screen
						during a presentation.
					</p>
				</section>

				<section>
					<h2>Stellar Links</h2>
					<ul>
						<li><a href="https://github.com/hakimel/reveal.js">Source code on GitHub</a></li>
						<li><a href="http://hakim.se/projects/reveal-js">Leave feedback on my site</a></li>
						<li><a href="http://twitter.com/hakimel">Follow me on Twitter</a></li>
					</ul>
				</section>

				<section>
					<h2>It's free</h2>
					<p>
						reveal.js and <a href="http://www.rvl.io">rvl.io</a> are entirely free but if you'd like to support the projects you can donate below.
						Donations will go towards hosting and domain costs.
					</p>
					<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
						<input type="hidden" name="cmd" value="_donations">
						<input type="hidden" name="business" value="hakim.elhattab@gmail.com">
						<input type="hidden" name="lc" value="US">
						<input type="hidden" name="item_name" value="reveal.js / rvl.io">
						<input type="hidden" name="no_note" value="0">
						<input type="hidden" name="currency_code" value="USD">
						<input type="hidden" name="bn" value="PP-DonationsBF:btn_donate_LG.gif:NonHostedGuest">
						<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
					</form>
				</section>

				<section class="git" data-state="git">
					<h1>THE END</h1>
					<h2>BAS</h2>
                    <h3>(Basarat Ali Syed)</h3>
					basarataliATgmail.com<br><br>
                    <a href="http://basarat.com">basarat.com</a><br>
					<a href="http://twitter.com/basarat">@basarat</a><br/>					
				</section>

			</div>

		</div>

        <a class="github" href="https://github.com/basarat" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

		<script src="lib/js/head.min.js"></script>
		<script src="lib/reveal.js"></script>
		<script src="lib/jquery.js"></script>
        <script type="text/javascript" data-main="./scripts/main.js" src="lib/require.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'concave', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

        <!--Custom Scripts-->
        <script>

            Reveal.addEventListener( 'slidechanged', function(data) {
                var currentSlide = $(data.currentSlide);

                // show git?
                var git = $(".github");
                if(currentSlide.hasClass("git"))
                    git.fadeIn();
                else
                    git.fadeOut();
            } );

        </script>

	</body>
</html>
